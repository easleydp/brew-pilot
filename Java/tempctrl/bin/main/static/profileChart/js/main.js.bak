const app = {
  minX: 0,
  maxX: 30 * 24,

  minY: -10,
  maxY: 40,

  formatTimeAsHtml: function(t) {
    t = Math.round(t); // Round to nearest hour (i.e. what we'll snap to)
    const days = Math.floor(t / 24) + 1;
    const hours = Math.floor(t % 24);
    if (days === 1) return `Hour&nbsp;${hours}`;
    return `Day&nbsp;${days}, hour&nbsp;${hours}`;
  },
};
Highcharts.chart('container', {
  chart: {
    type: 'line',
    animation: false,
    margin: [70, 50, 80, 80],
    // scrollablePlotArea: {  // Doesn't seem to play nicely with click to add after scroll
    //     minWidth: 2000
    // },
    events: {
      click: function(e) {
        let rawX = e.xAxis[0].value,
          y = Math.round(e.yAxis[0].value * 2) / 2,
          series = this.series[0],
          points = series.data,
          iLastPoint = points.length - 1,
          lastPoint = points[iLastPoint],
          lastPointX = lastPoint.x;

        if (rawX < app.minX) rawX = app.minX;
        else if (rawX > app.maxX) rawX = app.maxX;

        if (y < app.minY) y = app.minY;
        else if (y > app.maxY) y = app.maxY;

        // If rawX is > lastPoint but by less that 1 hr, nudge to lastPoint.x + 1 hr.
        // But if this puts it beyond maxX, ignore.
        if (rawX > lastPointX) {
          if (rawX - lastPointX < 1) {
            rawX = lastPointX + 1;
            if (rawX > app.maxX) return;
          }
        } else {
          // Not beyond last point
          // If there's only one point (0) and rawX is tending to 0, nudge forward.
          if (lastPointX === 0) {
            if (Math.round(rawX) === 0) rawX = 1;
          } else {
            // More than one point
            // Find the neighbouring points. Ensure the new point is ay least 1 hr from either. If there's
            // less than 2 hrs between the neighbours ignore.
            // Some detail:
            // If the rawX is exactly the same as that of an existing point:
            //   If that existing point is the first point (0), choose other neighbour to right.
            //   If that existing point is the last point, choose other neighbour to left.
            //   Otherwise, choose whichever way has most space.
            const iNearestP = series.data.reduce((iNearestP, p, i) => {
              const nearestP = iNearestP !== null ? points[iNearestP] : null;
              if (!nearestP || Math.abs(nearestP.x - rawX) > Math.abs(p.x - rawX)) iNearestP = i;
              return iNearestP;
            }, null);
            let nearestP = points[iNearestP];
            let otherNeighbourP;
            if (nearestP.x === rawX) {
              if (iNearestP === 0) {
                otherNeighbourP = points[1];
              } else if (iNearestP === iLastPoint) {
                otherNeighbourP = points[iNearestP - 1];
              } else {
                const spaceToLeft = nearestP.x - points[iNearestP - 1].x;
                const spaceToRight = (points[iNearestP + 1].x = nearestP.x);
                otherNeighbourP =
                  spaceToLeft > spaceToRight ? points[iNearestP - 1] : points[iNearestP + 1];
              }
            } else {
              otherNeighbourP =
                nearestP.x - rawX > 0 ? points[iNearestP - 1] : points[iNearestP + 1];
            }
            // Sort: ensure otherNeighbourP is later
            if (otherNeighbourP.x < nearestP.x)
              [nearestP, otherNeighbourP] = [otherNeighbourP, nearestP];
            if (otherNeighbourP.x - nearestP.x < 2) return;
            if (rawX - nearestP.x < 1) {
              rawX = nearestP.x + 1;
            } else if (otherNeighbourP.x - rawX < 1) {
              rawX = otherNeighbourP.x - 1;
            }
          }
        }

        let x = Math.round(rawX); // Round to nearest hour

        series.addPoint([x, y]);
      },
    },
  },
  title: {
    text: 'User supplied data',
  },
  subtitle: {
    text: 'Click the plot area to add a point. Click a point to remove it.',
  },
  // accessibility: {
  //     announceNewData: {
  //         enabled: true
  //     }
  // },
  tooltip: {
    useHTML: true,
    formatter: function() {
      // Round to nearest half a degree (or 1 degree F when we support F) (i.e. what we'll snap to)
      const friendlyTemp = `<b>${Math.round(this.y * 2) / 2}&deg;C</b>`;

      const i = this.point.index;
      if (i === 0) return `Start at ${friendlyTemp}`;

      const friendlyTime = app.formatTimeAsHtml(this.x);
      if (i === this.series.data.length - 1)
        return `Hold at ${friendlyTemp} from<br>${friendlyTime}`;
      return `${friendlyTemp} at<br>${friendlyTime}`;
    },
  },
  xAxis: {
    // type: 'datetime',
    labels: {
      formatter: function() {
        return app.formatTimeAsHtml(this.value);
      },
      useHTML: true,
      //staggerLines: 2
    },
    tickInterval: 12,
    minorTickInterval: 1,

    // scrollbar: {
    //     enabled: true
    // },

    gridLineWidth: 2,
    minRange: 14,
    maxPadding: 0.2,
    min: app.minX,
    max: app.maxX,
  },
  yAxis: {
    softMin: 10,
    softMax: 20,
    title: {
      useHTML: true,
      text: 'Temperature (&deg;C)',
    },
    minPadding: 0.2,
    maxPadding: 0.2,
    plotLines: [
      {
        value: 0,
        width: 1,
        color: '#808080',
      },
    ],
  },
  legend: {
    enabled: false,
  },
  exporting: {
    enabled: false,
  },
  plotOptions: {
    series: {
      lineWidth: 2,
      marker: {
        radius: 10,
        enabled: true, // Workaround the issue of point markers randomly all disappearing on adding a new point
      },
      point: {
        events: {
          click: function() {
            if (this.index !== 0) {
              // Don't remove first point
              this.remove();
            }
          },
          // dragStart: function (e) {
          //     console.log(0, e);
          //     // // Find this node's neighbours in the series (n1, n2) so we can constrain `drag` to (n1.x <= x <= n2.x).
          //     // const target = e.target;
          //     // const id = target.id;
          //     // const x = target.x;
          //     // const seriesData = target.series.data;
          //     // const iSeriesData = seriesData.map(d => d.id).indexOf(id);
          //     // app.n1x = seriesData[iSeriesData - 1];
          //     // app.n2x = seriesData[iSeriesData + 1];
          //     // console.log('dragStart', app);
          // },
          drag: function(e) {
            const x = e.newPoint.x;
            // Find this node's neighbours in the series (n1, n2) so we can constrain `drag` to (n1.x <= x <= n2.x).
            // Note: We'd have rather done this on dragStart but that event doesn't provide the point.
            if (!app.dragging) {
              app.dragging = true;
              const target = e.target;
              const seriesData = target.series.data;
              const iSeriesData = seriesData.map(d => d.id).indexOf(target.id);
              const n1 = seriesData[iSeriesData - 1];
              const n2 = seriesData[iSeriesData + 1];
              app.isFirstPoint = !n1;
              // Include 1 hr buffer (don't want two points with same x)
              app.n1x = n1 ? n1.x + 1 : Number.MIN_VALUE;
              app.n2x = n2 ? n2.x - 1 : Number.MAX_VALUE;
            }

            // Constrain to stay within neighbours' time range (including buffer)
            if (app.n1x > x || x > app.n2x) return false;

            // If it's the first point, keep x at 0.
            if (app.isFirstPoint && x) e.newPoint.x = 0;
          },
          drop: function(e) {
            app.dragging = false;

            // Snap x to nearest 1 hr
            const x = (e.newPoint.x = Math.round(e.newPoint.x));

            // Snap y to nearest half a degree (or 1 degree F when we support F)
            e.newPoint.y = Math.round(e.newPoint.y * 2) / 2;

            // Constrain to stay within neighbours' time range (including buffer)
            if (app.n1x > x) e.newPoint.x = app.n1x;
            else if (app.n2x < x) e.newPoint.x = app.n2x;
          },
        },
      },
      states: {
        hover: {
          halo: {
            size: 16,
          },
        },
      },
      stickyTracking: false,
      dragDrop: {
        draggableX: true,
        draggableY: true,

        dragMinX: app.minX,
        dragMinY: app.minY,

        dragMaxX: app.maxX,
        dragMaxY: app.maxY,

        //liveRedraw: false
      },
    },
    line: {
      cursor: 'move',
    },
  },
  series: [
    {
      //        data: [[0, 15], [14 * 24, 20]]
      data: [
        [0, 15],
        [1 * 24, 20],
      ],
    },
  ],
});
